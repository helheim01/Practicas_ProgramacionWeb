<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>To-Do List</title>

  <style>
    body { font-family: Arial, sans-serif; }
    .done { text-decoration: line-through; color: green; }
    ul { list-style: none; padding: 0; }
    li { background:#f0f0f0; margin:5px 0; padding:5px;
         display:flex; justify-content:space-between; align-items:center;}
    button { margin-left: 5px; }
  </style>

</head>
<body>
  <h2>To-Do List</h2>
  <input type="text" id="tarea" placeholder="Escribe una tarea...">
  <button id="agregar">Agregar</button>
  
  <ul id="lista"></ul>

  <h3>Registro de cambios en el DOM:</h3>
  <pre id="log"></pre>

  <script>
    /*
    EJERCICIO: To-Do List con manipulación del DOM y Observer pattern
    
    Conceptos clave:
    - DOM manipulation: crear, modificar y eliminar elementos HTML
    - Event delegation: manejar eventos de elementos dinámicos
    - MutationObserver: observar cambios en el DOM
    */
    
    //SELECCIÓN DE ELEMENTOS DEL DOM:
    const input = document.getElementById("tarea");     // Campo de texto
    const btnAgregar = document.getElementById("agregar"); // Botón agregar
    const lista = document.getElementById("lista");     // Lista ul
    const log = document.getElementById("log");         // Área de registro

    //MUTATIONOBSERVER: Observa cambios en el DOM
    const observer = new MutationObserver(muts => { //creo el observador
      muts.forEach(c => { // mutaciones: array con todos los cambios detectados
        log.textContent += `Cambio: ${c.type} en ${c.target.nodeName}\n`; //muestro los cambios
      });
    });

    /*
    CONFIGURAR EL OBSERVER:
    - observe(lista, opciones) → observa cambios en la lista
    - childList:true → detecta cuando se agregan/quitan elementos hijos
    - attributes:true → detecta cambios en atributos (como class)  
    - subtree:true → observa también elementos descendientes
    */
    observer.observe(lista, {childList:true, attributes:true, subtree:true});

    /*
    FUNCIÓN crearTarea(texto): Crea dinámicamente los elementos HTML para una tarea
    
    Estructura creada:
    <li>
      <span>texto de la tarea</span>
      <button class="completar">C</button>
      <button class="eliminar">E</button>
    </li>
    */
    function crearTarea(texto) {
      // Elemento li (contenedor de la tarea) (el ul ya está hecho en el html)
      const li = document.createElement("li");
      
      // Span para el texto de la tarea
      const span = document.createElement("span");
      span.textContent = texto; // la tarea en cuestion

      // Botón completar
      const btnC = document.createElement("button");
      btnC.textContent = "C";           // Texto del botón
      btnC.className = "completar";     // Clase para identificarlo

      // Botón eliminar  
      const btnE = document.createElement("button");
      btnE.textContent = "E";
      btnE.className = "eliminar";

      // Ensamblar: agregar span y botones al li
      li.append(span, btnC, btnE);
      return li; // Devolver el elemento completo
    }

    // EVENT LISTENER: Agregar tarea
    btnAgregar.addEventListener("click", () => { //ejecuta función al hacer click
      if(input.value.trim() === "") return; // Obtengo el texto, y valido que no esté vacío, si lo está, salgo de la funcion
      lista.appendChild(crearTarea(input.value)); // Agregar a la lista (ul) el nuevo li
      input.value = ""; // Limpiar campo
    });

    
    //EVENTOS DE LOS BOTONES: En lugar de agregar eventos a cada botón individualmente, agrego UN solo evento al contenedor padre (lista)
    lista.addEventListener("click", e => {
      if(e.target.classList.contains("eliminar")) { //e.target → elemento que fue clickeado y classList.contains() → verifica si tiene una clase específica
        e.target.closest("li").remove(); //closest("li") → busca el elemento li más cercano hacia arriba y lo elimina del DOM
      }
      else if(e.target.classList.contains("completar")) {
        e.target.closest("li").querySelector("span").classList.toggle("done");
      }
    });
  </script>
</body>
</html>