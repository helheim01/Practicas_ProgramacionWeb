<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>To-Do List</title>

  <style>
    body { font-family: Arial, sans-serif; }
    .done { text-decoration: line-through; color: green; }
    ul { list-style: none; padding: 0; }
    li { background:#f0f0f0; margin:5px 0; padding:5px;
         display:flex; justify-content:space-between; align-items:center;}
    button { margin-left: 5px; }
  </style>

</head>
<body>
  <h2>To-Do List</h2>
  <input type="text" id="tarea" placeholder="Escribe una tarea...">
  <button id="agregar">Agregar</button>
  
  <ul id="lista"></ul>

  <!-- Log para mostrar cambios detectados en el DOM -->
  <h3>Registro de cambios en el DOM:</h3>
  <pre id="log"></pre>

  <script>
    /*
    EJERCICIO: To-Do List con manipulación del DOM y Observer pattern
    
    Conceptos clave:
    - DOM manipulation: crear, modificar y eliminar elementos HTML
    - Event delegation: manejar eventos de elementos dinámicos
    - MutationObserver: observar cambios en el DOM
    */
    
    //SELECCIÓN DE ELEMENTOS DEL DOM:
    const input = document.getElementById("tarea");     // Campo de texto
    const btnAgregar = document.getElementById("agregar"); // Botón agregar
    const lista = document.getElementById("lista");     // Lista ul
    const log = document.getElementById("log");         // Área de registro

    /*
    MUTATIONOBSERVER: Observa cambios en el DOM
    
    - new MutationObserver() → crea un observador
    - muts → array de mutaciones (cambios) detectados
    - forEach(c => {}) → recorre cada cambio
    - log.textContent += → añade texto al registro
      - c.type → tipo de cambio (childList, attributes, etc.)
      - c.target.nodeName → nombre del elemento que cambió
    
    */
    const observer = new MutationObserver(muts => {
      muts.forEach(c => {
        log.textContent += `Cambio: ${c.type} en ${c.target.nodeName}\n`;
      });
    });

    /*
    CONFIGURAR EL OBSERVER:
    - observe(lista, opciones) → observa cambios en la lista
    - childList:true → detecta cuando se agregan/quitan elementos hijos
    - attributes:true → detecta cambios en atributos (como class)  
    - subtree:true → observa también elementos descendientes
    */
    observer.observe(lista, {childList:true, attributes:true, subtree:true});

    /*
    FUNCIÓN crearTarea(texto): Crea dinámicamente los elementos HTML para una tarea
    
    Estructura creada:
    <li>
      <span>texto de la tarea</span>
      <button class="completar">C</button>
      <button class="eliminar">E</button>
    </li>
    */
    function crearTarea(texto) {
      // Crear elemento li (contenedor de la tarea)
      const li = document.createElement("li");
      
      // Crear span para el texto de la tarea
      const span = document.createElement("span");
      span.textContent = texto; // Asignar el texto

      // Crear botón completar
      const btnC = document.createElement("button");
      btnC.textContent = "C";           // Texto del botón
      btnC.className = "completar";     // Clase para identificarlo

      // Crear botón eliminar  
      const btnE = document.createElement("button");
      btnE.textContent = "E";
      btnE.className = "eliminar";

      // Ensamblar: agregar span y botones al li
      li.append(span, btnC, btnE);
      return li; // Devolver el elemento completo
    }

    /*
    EVENT LISTENER: Agregar tarea
    
    - addEventListener("click", función) → ejecuta función al hacer click
    - input.value.trim() → obtiene el texto sin espacios al inicio/final
    - === "" → verifica si está vacío
    - return → sale de la función si no hay texto
    - appendChild() → agrega el nuevo li a la lista ul
    - input.value = "" → limpia el campo de texto
    */
    btnAgregar.addEventListener("click", () => {
      if(input.value.trim() === "") return; // Validar que no esté vacío
      lista.appendChild(crearTarea(input.value)); // Agregar a la lista
      input.value = ""; // Limpiar campo
    });

    /*
    DELEGACIÓN DE EVENTOS: En lugar de agregar eventos a cada botón individualmente, agregamos UN solo evento al contenedor padre (lista)
    
    Ventajas:
    - Funciona con elementos creados dinámicamente
    - Mejor rendimiento (menos event listeners)
    - Código más limpio
    */
    lista.addEventListener("click", e => {
      /*
      e.target → elemento que fue clickeado
      classList.contains() → verifica si tiene una clase específica
      */
      
      if(e.target.classList.contains("eliminar")) {
        /*
        ELIMINAR TAREA:
        - closest("li") → busca el elemento li más cercano hacia arriba
        - remove() → elimina el elemento del DOM
        */
        e.target.closest("li").remove();
      }
      else if(e.target.classList.contains("completar")) {
        /*
        COMPLETAR TAREA:
        - closest("li") → encuentra el li contenedor
        - querySelector("span") → encuentra el span dentro del li
        - classList.toggle("done") → añade/quita la clase "done"
        
        La clase "done" tiene CSS que muestra línea tachada y color verde
        */
        e.target.closest("li").querySelector("span").classList.toggle("done");
      }
    });
  </script>
</body>
</html>