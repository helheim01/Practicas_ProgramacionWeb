<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // ================================
        // Errors & Exceptions en JavaScript
        // ================================

        // Errores de sintaxis, sem√°nticos o l√≥gicos (manejarlos con t√©cnicas como try...catch)

        // ================================
        // 1. Syntax Error (Error de sintaxis): Rompe el inicio
        // ================================

        // ‚ùå Falta una coma entre par√°metros:
        let multiplySyntaxError = (a b) => a + b; 
        // -> Uncaught SyntaxError: Unexpected identifier
        // Explicaci√≥n: El motor JS no puede interpretar la instrucci√≥n porque la "gram√°tica" del lenguaje fue escrita de forma incorrecta.

        // Se produce cuando el c√≥digo est√° mal formado
        "use strict";
        // ‚ùå Escribimos mal "if" como "iff"
        iff (true) { // -> Uncaught SyntaxError: Unexpected token '{'
        // El motor no puede ni empezar a ejecutar el programa
            console.log("true");
        }

        // ================================
        // 2. Semantic Error (Error sem√°ntico / ReferenceError): Referencia o palabra inexistente.
        // ================================

        // ‚ùå Definimos la funci√≥n como "multipl" pero la llamamos como "multiply"
        let multipl = (a, b) => a + b; 
        let resultSemanticError = multiply(10, 20); 
        // -> Uncaught ReferenceError: multiply is not defined
        // Explicaci√≥n: "multiply" no existe, es un error de referencia. El programa se detiene en esa l√≠nea.

        // Intentamos usar una variable o funci√≥n que NO existe
        try {
            let a = b; // ‚ùå "b" no est√° definida
        } catch (error) {
            console.log("Caught " + error); // -> Caught ReferenceError: b is not defined
        }

        try {
            fun(); // ‚ùå No existe la funci√≥n "fun"
        } catch (error) {
            console.log("Caught " + error); // -> Caught ReferenceError: fun is not defined
        }

        // ================================
        // 3. Logical Error (Error l√≥gico): Corre, pero da resultados equivocados.
        // ================================

        // ‚ùå Todo funciona, pero la l√≥gica est√° mal:
        let multiplyLogic = (a, b) => a + b; 
        let resultLogic = multiplyLogic(10, 20);
        console.log(resultLogic); // -> 30 ‚ùå (se espera 200)
        // Explicaci√≥n: el programa corre sin problemas, pero en vez de multiplicar suma. Son los m√°s dif√≠ciles de detectar autom√°ticamente.

        // ‚úÖ Correcci√≥n:
        let multiply = (a, b) => a * b;
        let resultOk = multiply(10, 20);
        console.log(resultOk); // -> 200 ‚úÖ

        // 4. TypeError (Error de tipo)
        // Sucede cuando usamos un valor con un tipo no v√°lido
        try {
            const someConstValue = 5;
            someConstValue = 7; // ‚ùå No se puede reasignar una constante
        } catch (error) {
            console.log("Caught " + error); // -> Assignment to constant variable
        }

        try {
            let someNumber = 10;
            someNumber.length(); // ‚ùå length no existe en n√∫meros
        } catch (error) {
            console.log("Caught " + error); // -> someNumber.length is not a function
        }

        // 5. RangeError (Error de rango)
        // Se da cuando usamos un valor fuera del rango permitido
        try {
            let testArray1 = Array(10); // ‚úÖ crea array de longitud 10
            console.log(testArray1.length); // -> 10
            let testArray2 = Array(-1); // ‚ùå longitud negativa
        } catch (error) {
            console.log("Caught " + error); // -> Invalid array length
        }

        // Otros errores menos comunes: EvalError, InternalError, URIError.

        // ================================
        // 4. Excepciones en JavaScript
        // ================================

        // ‚ùå ReferenceError: typo en "console"
        console.log("abc");   // ‚úÖ imprime "abc"
        conole.log("def");    // ‚ùå ReferenceError: conole is not defined
        console.log("ghi");   // ‚ùå nunca llega a ejecutarse

        // ‚úÖ Manejo con try...catch:
        try {
            console.log("abc");   // ‚úÖ funciona
            conole.log("def");    // ‚ùå genera excepci√≥n
        } catch (error) {
            console.log("Se atrap√≥ un error:");
            console.log(error.message); // -> conole is not defined
        }
        console.log("El programa contin√∫a despu√©s del catch ‚úÖ");


        // ================================
        // 5. Errores sin excepci√≥n
        // ================================

        // No siempre hay un "throw" de error. 
        // Devuelve valores NaN o Infinity.

        console.log(100 / 0);      // -> Infinity ‚ùå (divisi√≥n por cero)
        console.log(100 * "2");    // -> 200 ‚úÖ (conversi√≥n autom√°tica de string a n√∫mero)
        console.log(100 * "abc");  // -> NaN ‚ùå (no se puede convertir a n√∫mero)

        console.log(Math.pow("abc", "def")); // -> NaN ‚ùå
        // Explicaci√≥n: No se lanza excepci√≥n, solo devuelve "NaN".


        // ================================
        // 6. Validaci√≥n de datos (Confianza limitada)
        // ================================

        // Desconfiar del input del usuario.
        // Ejemplo: pedimos dos n√∫meros y validamos antes de dividir.
        let sX = prompt("Enter the first number");  
        let sY = prompt("Enter the second number");

        let x = Number(sX);
        let y = Number(sY);

        // Validamos con Number.isFinite y chequeamos divisor distinto de 0
        if (Number.isFinite(x) && Number.isFinite(y) && y !== 0) {
            console.log(x / y); // ‚úÖ Divisi√≥n v√°lida
        } else {
            console.log("Incorrect arguments ‚ùå");
        }


        //----------------------------------------------------------------------------------

        // ================================
        // üìå try...catch
        // ================================

        // Sintaxis b√°sica:
        // try { ... } catch(error) { ... }

        try {
            let a = b; // ‚ùå ReferenceError
        } catch (error) {
            console.log("Caught " + error); // -> atrapado
        }
        console.log("El programa contin√∫a despu√©s del catch ‚úÖ");

        // Nota: try...catch no atrapa SyntaxError, porque el c√≥digo ni siquiera arranca.

        // ================================
        // üìå Manejo condicional con instanceof
        // ================================

        let a = -2;
        try {
            a = b; // ‚ùå ReferenceError
        } catch (error) {
            if (error instanceof ReferenceError) {
                console.log("Reference error, reset a to -2"); 
                a = -2; // Recuperamos el valor
            } else {
                console.log("Otro tipo de error: " + error);
            }
        }
        console.log(a); // -> -2

        // Explicaci√≥n: instanceof permite diferenciar el tipo de error atrapado.

        // ================================
        // üìå finally
        // ================================

        // finally se ejecuta SIEMPRE, haya error o no

        let x = 10;
        try {
            x = 5; // ‚úÖ sin error
        } finally {
            console.log(x); // -> 5 (se ejecuta s√≠ o s√≠)
        }
        console.log(x); // -> 5

        // Caso con error:
        let y = 10;
        try {
            y = b; // ‚ùå ReferenceError
        } finally {
            console.log(y); // -> 10 (se ejecuta igual)
        }
        // El programa se detiene porque no hay catch.

        // Uso combinado de catch + finally
        let z = 10;
        try {
            z = b; // ‚ùå ReferenceError
        } catch (error) {
            console.log("An Error!"); 
        } finally {
            console.log("Finally!"); // Siempre se ejecuta
        }
        console.log(z); // -> 10

        // ================================
        // üìå ¬øPor qu√© usar finally?
        // ================================

        // Diferencia: finally corre incluso si ocurre otro error en el catch.

        let n = 10;
        try {
            n = b; // ‚ùå Primer ReferenceError
        } catch (error) {
            console.log(b); // ‚ùå Segundo ReferenceError
        }
        console.log("Finally!"); // ‚ùå Nunca se ejecuta

        // Con finally:
        let m = 10;
        try {
            m = b; // ‚ùå Primer ReferenceError
        } catch (error) {
            console.log(b); // ‚ùå Segundo ReferenceError
        } finally {
            console.log("Finally!"); // ‚úÖ Se ejecuta siempre
        }

        // Tambi√©n podemos anidar try...catch
        let q = 10;
        try {
            q = b; // ‚ùå ReferenceError
        } catch (error) {
            try {
                console.log(b); // ‚ùå Segundo ReferenceError
            } catch {
                console.log("Second catch!"); // ‚úÖ atrapado
            }
        } finally {
            console.log("Finally!"); // ‚úÖ
        }

        // ================================
        // üìå throw y errores personalizados
        // ================================

        // Podemos lanzar nuestras propias excepciones con "throw"

        // Ejemplo b√°sico
        console.log("start"); // -> start
        try {
            throw 100; // Lanzamos el n√∫mero 100 como excepci√≥n
        } catch (error) {
            console.log(error); // -> 100
        }
        console.log("end"); // -> end

        // Ejemplo m√°s √∫til: factorial con validaci√≥n
        function factorial(n) {
            if (n > 20) {
                // Lanzamos un error de tipo RangeError con mensaje personalizado
                throw new RangeError("Max value 20");
            }
            let result = 1;
            for (; n > 1; n--) {
                result = result * n;
            }
            return result;
        }

        try {
            console.log(factorial(5));  // ‚úÖ -> 120
            console.log(factorial(20)); // ‚úÖ -> n√∫mero grande
            console.log(factorial(1000)); // ‚ùå lanza RangeError
        } catch (error) {
            console.log("Error atrapado: " + error.message); // -> Max value 20
        }


        /*
        Ejercicio 1: Escribe tu propia funci√≥n div que reciba dos argumentos y devuelva el resultado de dividir el primer argumento entre el segundo.
        En JavaScript, el resultado de dividir entre cero es el valor Infinity (o -Infinity, si intentamos dividir un n√∫mero negativo). 
        Cambia este comportamiento:
        Si pasas 0 como segundo argumento, tu funci√≥n debe lanzar una excepci√≥n RangeError con un mensaje adecuado.
        Prepara una llamada de prueba de la funci√≥n tanto para una divisi√≥n v√°lida como para una divisi√≥n entre cero.
        */

        let var1=(prompt("Ingresa el primer valor: "));
        let var2=(prompt("Ingrese el segundo valor: "))

        A=Number(var1);
        B=Number(var2);

        div=(x,y)=>{
            if (Number.isInteger(x) || Number.isInteger(y)) {
                    alert("Error: valores no v√°lidos");
            } else if (y==0){
                throw new RangeError("No se puede dividir por 0");
            }else{
                return x/y;
            }
        }

        try{
            let reesultado=div(A,B);
            alert("Resultado: " + reesultado);
        }catch (error){
            alert(error.message);
        }


        /*
        Ejercicio 2:
        Se ha declarado el siguiente arreglo de n√∫meros: let numbers = [10, 40, 0, 20, 50];
        Escribe un programa que, dentro de un bucle, divida el n√∫mero 1000 por los elementos sucesivos del arreglo numbers, 
        mostrando el resultado de cada divisi√≥n.
        Para realizar la divisi√≥n, utiliza la funci√≥n del ejercicio anterior.
        Usa la construcci√≥n try...catch para manejar la excepci√≥n que se lanza en el caso de divisi√≥n por cero.
        Si se captura esa excepci√≥n, el programa debe imprimir un mensaje adecuado (tomado de la excepci√≥n) y continuar su
        ejecuci√≥n (realizando la divisi√≥n con los elementos siguientes del arreglo).
        */

        let numbers = [10, 40, 0, 20, 50];

        for(let i=0;i<numbers.length;i++){
            try{
                let resultadoArreglo=div(1000, numbers[i]);
                console.log("1000 / " + numbers[i] + " = " + resultadoArreglo);
            }catch(error){
                console.log("Error con 1000 / " + numbers[i] + " = " + error.message);
            }
        }


        //-------------------------------------------------------------------------------------------------------------------------------------------------------------
        //-------------------------------------------------------------------------------------------------------------------------------------------------------------


        // ====================================================================
        //Testing and debugging your code
        // ====================================================================

        // ‚ùå Ejemplo de un error l√≥gico (no de sintaxis)
        function average(a, b) {
            // ERROR: la divisi√≥n se hace primero, as√≠ que no calcula el promedio real
            return a + b / 2;
        }
        console.log(average(2, 10)); // -> 7 (esper√°bamos 6)
        console.log(average(5, 5));  // -> 7.5 (esper√°bamos 5)

        // üîé El error est√° en el orden de operaciones
        // a + b / 2 = a + (b/2)
        // Soluci√≥n correcta:
        function averageFixed(a, b) {
            return (a + b) / 2; // ‚úÖ Ahora s√≠ calcula el promedio
        }
        console.log(averageFixed(2, 10)); // -> 6
        console.log(averageFixed(5, 5));  // -> 5

        // ====================================================================
        // Otro ejemplo con errores l√≥gicos m√°s sutiles
        // ====================================================================
        function largest(a, b, c) {
            if (a > b && a > c) {
                return a;
            } else if (b > a && b > c) {
                return b;
            } else {
                return c;
            }
        }

        // üß™ Pruebas
        console.log(largest(1, 1, 2)); // -> 2 (Correcto)
        console.log(largest(1, 2, 3)); // -> 3 (Correcto)
        console.log(largest(3, 2, 1)); // -> 3 (Correcto)
        console.log(largest(2, 2, 1)); // -> 1 (‚ùå Incorrecto: deber√≠a ser 2)

        // ‚ùå El problema: cuando dos valores son iguales, la condici√≥n ">" falla.
        // ‚úÖ Soluci√≥n: usar >= en vez de solo >.
        function largestFixed(a, b, c) {
            if (a >= b && a >= c) {
                return a;
            } else if (b >= a && b >= c) {
                return b;
            } else {
                return c;
            }
        }
        console.log(largestFixed(2, 2, 1)); // -> 2 ‚úÖ Corregido

        // ====================================================================
        // 6.2.2 Debugger b√°sico
        // ====================================================================

        console.log("Before debugger");
        debugger; // Pausa el c√≥digo aqu√≠ si la consola de desarrollo est√° abierta
        console.log("After debugger"); // No se ejecuta hasta continuar en el debugger

        // ====================================================================
        // 6.2.4 Ejemplo de outer() y inner()
        // ====================================================================

        function outer() {
            let name = "outer";
            let str = inner();
            return str;
        }
        function inner() {
            let name = "inner";
            return "Hello !";
        }
        console.log("before outer() call");
        console.log(outer());  // -> "Hello !"
        console.log("after outer() call");

        // Si ponemos debugger antes del outer():
        console.log("before outer() call");
        debugger; // Aqu√≠ el navegador pausa y nos deja ejecutar paso a paso
        console.log(outer());
        console.log("after outer() call");

        // ====================================================================
        // Step Over y Step Into
        // ====================================================================
        // - Step Over: ejecuta la funci√≥n como un bloque sin entrar dentro.
        // - Step Into: entra l√≠nea por l√≠nea en la funci√≥n llamada.
        // - Step Out: sale de la funci√≥n y vuelve a donde fue llamada.

        // ====================================================================
        // Call stack y scopes
        // ====================================================================
        // Cuando outer llama a inner(), se forma una "pila de llamadas":
        // [global] -> outer -> inner
        // Podemos inspeccionar variables en cada contexto desde la consola.
        // Ejemplo:
        // console.log(name); // dentro de inner -> "inner"
        // console.log(name); // en outer -> "outer"

        // ====================================================================
        // Step out
        // ====================================================================
        // Resume la ejecuci√≥n hasta salir de la funci√≥n actual y volver a la anterior.

        // ====================================================================
        // Medici√≥n de tiempo con console.time y console.timeEnd
        // ====================================================================

        // Aproximaci√≥n de PI usando la serie de Leibniz
        let part = 0;
        console.time('Leibniz'); // ‚è± Empieza el cron√≥metro
        for (let k = 0; k < 1000000; k++) {
            part = part + ((-1) ** k) / (2 * k + 1);
        }
        console.timeEnd('Leibniz'); // ‚è± Termina y muestra el tiempo
        let pi = part * 4;
        console.log(pi); // -> Aproximaci√≥n de PI

        // Optimizaci√≥n: evitar usar potencia ** en cada iteraci√≥n
        let partOpt = 0;
        console.time('LeibnizOptimizado');
        for (let k = 0; k < 1000000; k++) {
            partOpt = partOpt + (k % 2 ? -1 : 1) / (2 * k + 1);
        }
        console.timeEnd('LeibnizOptimizado');
        let piOpt = partOpt * 4;
        console.log(piOpt); // -> Aproximaci√≥n de PI (m√°s r√°pido)

        // ====================================================================
        // Resumen:
        // - Errores l√≥gicos no siempre son detectados por el int√©rprete.
        // - debugger permite pausar y examinar paso a paso.
        // - Breakpoints se ponen en el navegador sin usar c√≥digo.
        // - console.time y console.timeEnd permiten medir performance.
        // ====================================================================

        /*
        Ejercicio 1: Ejecut√° el siguiente c√≥digo:
            let end = 2;
            for (let i = 1; i <= end; i++) {
                console.log(i);
            }

            Deber√≠a imprimir 1 y 2 en la consola.
            Us√° el debugger para hacer que el programa imprima 1, 2, 3, 4, 5 en la consola sin modificar el c√≥digo: 
            s√≥lo pod√©s usar breakpoints y la opci√≥n de modificar variables en el depurador.

        
        Ejercicio 2: Us√° el depurador para entender por qu√© el resultado final impreso es igual a 0 cuando en cada iteraci√≥n la 
        variable result parece aumentar. Us√° Watch para seguir los cambios de las variables seleccionadas.

            let counter = 0;
            let maxValue = 10;
            let result = 1;
            debugger;
            for (counter = 0; counter < maxValue; counter++) {
                console.log(result);
                result *= maxValue - counter - 1;
            }
            console.log("Final result: ", result);

        Ejercicio 3: Ejecut√° este c√≥digo:

            function max(array) {
                let maxValue = array[1];
                for (let i = 1; i < array.length; i++) {
                    if (array[i] > maxValue) {
                        maxValue = array[i];
                    }
                }
                return maxValue;
            }
            console.log(max([1, 4, 6, 2]));  // -> 6
            console.log(max([10, 4, 6, 2])); // -> 6  (incorrecto; deber√≠a devolver 10)

            La funci√≥n max deber√≠a devolver el n√∫mero mayor del array. En el segundo caso devuelve 6 en lugar de 10. Us√° el debugger para seguir 
            la ejecuci√≥n paso a paso, observ√° i y maxValue, localiz√° el problema y arregl√° el c√≥digo.
        */
    </script>
</body>
</html>